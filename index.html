<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Hero Dash — Color Edition</title>
<style>
  :root {
    --ui-bg: #0a0a12;
    --ui-card: rgba(255,255,255,.07);
    --ui-glass-a: rgba(255,255,255,.09);
    --ui-glass-b: rgba(255,255,255,.03);
    --text: #f2f6ff;
    --hud-pill: rgba(0,0,0,.35);
    --hud-border: rgba(255,255,255,.15);
    --bar-bg: rgba(255,255,255,.12);
    --bar-border: rgba(255,255,255,.2);
    --life-a: #22c55e; --life-b: #16a34a;
    --eng-a: #f59e0b; --eng-b: #ef4444;
    --boss-a: #ef4444; --boss-b: #991b1b;
  }
  html, body { margin: 0; height: 100%; background: #0e0e15; color: var(--text); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  #wrap { min-height: 100%; display: grid; place-items: center; }
  #gamePanel { position: relative; width: min(100vw, 1100px); aspect-ratio: 16/9; background: var(--ui-bg); border-radius: 16px; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,.5), inset 0 0 0 1px rgba(255,255,255,.07); }
  canvas { display: block; width: 100%; height: 100%; background: #080b12; }

  /* HUD */
  #hud { position: absolute; top: 10px; left: 10px; right: 10px; display: flex; align-items: center; justify-content: space-between; gap: 10px; user-select: none; text-shadow: 0 2px 4px rgba(0,0,0,.6); }
  .pill { background: var(--hud-pill); padding: 8px 12px; border-radius: 999px; border: 1px solid var(--hud-border); font-weight: 800; }
  .bar { height: 10px; background: var(--bar-bg); border: 1px solid var(--bar-border); border-radius: 999px; overflow: hidden; }
  #lifeFill { height: 100%; width: 100%; background: linear-gradient(90deg, var(--life-a), var(--life-b)); }
  #energyFill { height: 100%; width: 0%; background: linear-gradient(90deg, var(--eng-a), var(--eng-b)); }
  #bossBar { position: absolute; top: 48px; left: 10px; right: 10px; display: none; }
  #bossFill { height: 10px; width: 0%; background: linear-gradient(90deg, var(--boss-a), var(--boss-b)); border-radius: 999px; }

  /* Overlays */
  .overlay { position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none; }
  .card { pointer-events: auto; backdrop-filter: blur(10px); background: linear-gradient(160deg, var(--ui-glass-a), var(--ui-glass-b)); border: 1px solid var(--hud-border); border-radius: 14px; padding: 18px; width: min(95%, 880px); box-shadow: 0 10px 24px rgba(0,0,0,.35); }
  .row { display: flex; flex-wrap: wrap; gap: 14px; margin: 10px 0; }
  .col { flex: 1 1 210px; min-width: 200px; }
  label { display: block; font-size: 14px; margin-bottom: 6px; opacity: .85; }
  select, button { width: 100%; padding: 10px 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,.2); background: rgba(0,0,0,.35); color: var(--text); font-weight: 700; }
  button.cta { background: linear-gradient(135deg, #8b5cf6, #06b6d4); border: none; cursor: pointer; transition: transform .06s ease; }
  button.cta:active { transform: translateY(2px) scale(0.99); }
  .hint { opacity: .78; font-size: 12px; margin-top: 6px; }

  /* Touch controls — big colorful circles: ⚡ left, ⏸ center, ⬆ right */
  #touchControls { position: absolute; bottom: 10px; left: 10px; right: 10px; display: flex; gap: 12px; pointer-events: none; align-items: flex-end; }
  .pad { pointer-events: auto; flex: 1 1 33%; display: grid; place-items: center; }
  .btn {
    width: clamp(64px, 14vw, 120px); height: clamp(64px, 14vw, 120px);
    border-radius: 50%; display: grid; place-items: center; font-weight: 900; font-size: clamp(20px, 4.5vw, 34px);
    border: 2px solid rgba(255,255,255,.22); color: white; text-shadow: 0 2px 6px rgba(0,0,0,.5);
    box-shadow: 0 8px 18px rgba(0,0,0,.4), inset 0 0 20px rgba(255,255,255,.12);
    user-select: none;
  }
  #powerBtn { background: radial-gradient(circle at 30% 30%, #f59e0b, #ef4444); }
  #pauseBtn { background: radial-gradient(circle at 30% 30%, #60a5fa, #3b82f6); }
  #jumpBtn  { background: radial-gradient(circle at 30% 30%, #34d399, #10b981); }
  .btn:active { transform: scale(0.96); filter: brightness(1.08); }
  .cooldown { position: absolute; width: 100%; height: 100%; border-radius: 50%; background: rgba(0,0,0,.35); inset: 0; pointer-events: none; clip-path: inset(0 0 var(--cool, 0%) 0); }

  @media (hover: hover) and (pointer: fine) { #touchControls { display: none; } } /* hide on desktop with mouse */
</style>
</head>
<body>
<div id="wrap">
  <div id="gamePanel">
    <canvas id="game" width="960" height="540"></canvas>

    <div id="hud">
      <div class="pill">Score: <span id="score">0</span></div>
      <div style="display:flex; align-items:center; gap:10px;">
        <div class="pill">Grade: <span id="gradeHUD">3</span></div>
        <div class="pill">Lives</div>
        <div class="bar" style="width:140px;"><div id="lifeFill"></div></div>
        <div class="pill">Energy</div>
        <div class="bar" style="width:160px;"><div id="energyFill"></div></div>
      </div>
    </div>

    <div id="bossBar"><div id="bossFill"></div></div>

    <!-- Menu -->
    <div class="overlay" id="menuOverlay">
      <div class="card">
        <h1 style="margin:0 0 8px; letter-spacing:.5px;">Hero Dash</h1>
        <div class="row">
          <div class="col">
            <label for="grade">Grade (Difficulty)</label>
            <select id="grade">
              <option value="3">3</option><option value="4">4</option><option value="5">5</option>
              <option value="6">6</option><option value="7">7</option><option value="8">8</option><option value="9">9</option>
            </select>
          </div>
          <div class="col">
            <label for="hero">Hero</label>
            <select id="hero">
              <option value="tech">Tech Titan • blast</option>
              <option value="web">Web Racer • slow-mo + double jump</option>
              <option value="bolt">Bolt Runner • dash</option>
              <option value="shield">Shield Star • shield</option>
              <option value="mage">Nova Mage • nova</option>
            </select>
          </div>
          <div class="col">
            <label for="bg">World</label>
            <select id="bg">
              <option value="city">City</option>
              <option value="space">Space</option>
              <option value="jungle">Jungle</option>
            </select>
          </div>
          <div class="col">
            <label for="theme">Theme</label>
            <select id="theme">
              <option value="rainbow">Rainbow</option>
              <option value="ocean">Ocean</option>
              <option value="sunset">Sunset</option>
              <option value="candy">Candy</option>
              <option value="forest">Forest</option>
            </select>
          </div>
          <div class="col">
            <label for="perf">Performance</label>
            <select id="perf">
              <option value="auto">Auto</option>
              <option value="high">High</option>
              <option value="low">Ultra</option>
            </select>
          </div>
        </div>
        <div class="row">
          <div class="col" style="max-width:220px;"><button id="startBtn" class="cta">Start</button></div>
        </div>
        <div class="hint">Jump: Space/Up • Power: F • Pause: P • Mobile: ⚡ ⏸ ⬆</div>
      </div>
    </div>

    <!-- Game Over -->
    <div class="overlay" id="gameOverOverlay" style="display:none;">
      <div class="card" style="text-align:center;">
        <h2 style="margin:0 0 10px;">Game Over</h2>
        <div style="margin:6px 0;">Score: <b id="finalScore">0</b> • Best: <b id="bestScore">0</b></div>
        <div class="row" style="justify-content:center;">
          <div class="col" style="max-width:220px;"><button id="retryBtn" class="cta">Retry</button></div>
          <div class="col" style="max-width:220px;"><button id="menuBtn" class="cta" style="background:linear-gradient(135deg,#10b981,#22c55e);">Menu</button></div>
        </div>
      </div>
    </div>

    <!-- Touch controls -->
    <div id="touchControls">
      <div class="pad" style="justify-self:start;">
        <div id="powerBtn" class="btn">⚡<div id="powerCD" class="cooldown" style="--cool:0%;"></div></div>
      </div>
      <div class="pad" style="justify-self:center;">
        <div id="pauseBtn" class="btn">⏸</div>
      </div>
      <div class="pad" style="justify-self:end;">
        <div id="jumpBtn" class="btn">⬆</div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // Canvas and context
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });

  // UI
  const menuOverlay = document.getElementById('menuOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const startBtn = document.getElementById('startBtn');
  const retryBtn = document.getElementById('retryBtn');
  const menuBtn = document.getElementById('menuBtn');

  const gradeSel = document.getElementById('grade');
  const heroSel = document.getElementById('hero');
  const bgSel = document.getElementById('bg');
  const themeSel = document.getElementById('theme');
  const perfSel = document.getElementById('perf');

  const scoreHUD = document.getElementById('score');
  const gradeHUD = document.getElementById('gradeHUD');
  const lifeFill = document.getElementById('lifeFill');
  const energyFill = document.getElementById('energyFill');
  const finalScoreEl = document.getElementById('finalScore');
  const bestScoreEl = document.getElementById('bestScore');

  const bossBar = document.getElementById('bossBar');
  const bossFill = document.getElementById('bossFill');

  // Touch buttons
  const jumpBtn = document.getElementById('jumpBtn');
  const powerBtn = document.getElementById('powerBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const powerCDMask = document.getElementById('powerCD');

  // Color themes (for everyone)
  const themes = {
    rainbow: { obsA: '#facc15', obsB: '#f97316', skyA:'#3b82f6', skyB:'#9333ea', orb:'#f59e0b' },
    ocean:   { obsA: '#7dd3fc', obsB: '#0ea5e9', skyA:'#0369a1', skyB:'#0b1020', orb:'#8b5cf6' },
    sunset:  { obsA: '#fb7185', obsB: '#f97316', skyA:'#7c2d12', skyB:'#0a0810', orb:'#fbbf24' },
    candy:   { obsA: '#f472b6', obsB: '#a78bfa', skyA:'#4c1d95', skyB:'#120a1f', orb:'#f472b6' },
    forest:  { obsA: '#86efac', obsB: '#22c55e', skyA:'#064e3b', skyB:'#0b2a16', orb:'#34d399' },
  };
  let palette = themes.rainbow;

  // Audio SFX (safe types)
  const SFX = (() => {
    let ac, master, sfx;
    function ensure(){ if(!ac){ const AC = window.AudioContext || window.webkitAudioContext; if(!AC) return; ac = new AC(); master=ac.createGain(); master.gain.value=.8; master.connect(ac.destination); sfx=ac.createGain(); sfx.gain.value=.7; sfx.connect(master); } if(ac.state==='suspended') ac.resume(); }
    function env(g,t,a=.005,d=.12){ g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(.0001,t); g.gain.linearRampToValueAtTime(.25,t+a); g.gain.exponentialRampToValueAtTime(.0001,t+a+d); }
    function beep(type, f1, f2, dur){ if(!ac) return; const t=ac.currentTime; const o=ac.createOscillator(), g=ac.createGain(); o.type=type; o.connect(g); g.connect(sfx); o.frequency.setValueAtTime(f1,t); if(f2) o.frequency.exponentialRampToValueAtTime(f2, t+dur*.6); env(g,t,.003,dur); o.start(t); o.stop(t+dur*1.05); }
    return {
      ensure,
      jump(){ beep('square',420,620,0.12); },
      orb(){ beep('triangle',660,1100,0.09); },
      shoot(){ beep('sawtooth',520,260,0.08); },
      hit(){ if(!ac) return; const t=ac.currentTime; const o=ac.createOscillator(), g=ac.createGain(); o.type='square'; o.connect(g); g.connect(sfx); o.frequency.setValueAtTime(140,t); env(g,t,0.004,0.16); o.start(t); o.stop(t+0.18); },
      boss(){ beep('triangle',220,180,0.4); },
      win(){ beep('square',660,990,0.4); },
      pause(){ beep('square',320,320,0.07); }
    };
  })();

  // Game state
  const state = {
    running:false, paused:false, perf:'auto',
    grade:3, hero:'tech', bg:'city',
    score:0, best:Number(localStorage.getItem('heroDashBestColor')||0),
    lives:3, maxLives:3, energy:0, maxEnergy:6,
    invTime:0, timeScale:1,
    baseSpeed:360, gravity:1900, groundY:0,
    nextBossAt:260
  };

  // Player and entities
  const player = { x:120,y:0,w:44,h:60,vx:0,vy:0,onGround:false,doubleJump:false,powerCD:0, slowTime:0,dash:0,shield:0 };
  const bullets=[], obstacles=[], orbs=[], fxBursts=[];
  const boss = { active:false, hp:0, maxHp:0, x:0,y:0,w:140,h:100,t:0, fireTimer:0, coreTimer:0 };
  const bossShots=[], bossCores=[];
  let tPrev=0, obstacleTimer=0, orbTimer=0;
  const bgState={ t:0, cityFar:0, cityNear:0, starsA:0, starsB:0, jungleFar:0, jungleNear:0 };

  // Fairness helpers
  let coyote=0, jumpBuffer=0;
  const COYOTE_MAX = 0.12;   // 120ms after leaving ground, still jump
  const BUFFER_MAX = 0.15;   // 150ms buffered jump
  const SAFE_START = 2.0;    // first seconds: no obstacles
  let timeSinceStart = 0;

  // Resize/DPR
  function resizeCanvas(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
    const w = Math.round(cssW*dpr), h = Math.round(cssH*dpr);
    if(canvas.width!==w || canvas.height!==h){ canvas.width=w; canvas.height=h; }
    ctx.setTransform(1,0,0,1,0,0);
    ctx.imageSmoothingEnabled = false;
    state.groundY = canvas.height - Math.round(100*dpr);
  }
  window.addEventListener('resize', resizeCanvas); resizeCanvas();

  // Utils
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  function rand(seed){ const x=Math.sin(seed*12.9898)*43758.5453; return x-Math.floor(x); }
  function difficultyFromGrade(g){
    const t=(g-3)/6;
    return {
      speedMul: 0.9 + t*0.7,
      obstacleEvery: 1.0 - t*0.45,  // base timer (we’ll enforce min gaps too)
      orbEvery: 0.9 + t*0.5,
      bossHP: 8 + Math.round(t*8),
      reactTime: 1.05 - t*0.35 // required seconds of space before an obstacle
    };
  }
  function perfDetail(){ if(state.perf==='low') return 0; if(state.perf==='high') return 2; const px=canvas.width*canvas.height; return px>1_500_000?0:1; }

  // Hitboxes with mercy (forgiveness)
  function heroHitbox() {
    const padX = player.w*0.18, padY = player.h*0.12;
    return { x: player.x+padX, y: player.y+padY, w: player.w - padX*2, h: player.h - padY*2 };
  }
  function rectsOverlap(a,b){ return (a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y); }
  function circleRectOverlap(cx, cy, r, rx, ry, rw, rh){
    const cx2 = Math.max(rx, Math.min(rx+rw, cx));
    const cy2 = Math.max(ry, Math.min(ry+rh, cy));
    const dx = cx - cx2, dy = cy - cy2;
    return dx*dx + dy*dy <= r*r;
  }

  // Drawing basics
  function drawRoundedRect(x,y,w,h,r){ ctx.beginPath(); r=Math.min(r,w/2,h/2); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

  // Backgrounds (tinted by palette)
  function drawBackground(dt, spd){
    const W=canvas.width, H=canvas.height, ground=state.groundY;
    if(state.bg==='city'){
      const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,palette.skyA); g.addColorStop(1,palette.skyB); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
      bgState.cityFar+=dt*spd*0.14; bgState.cityNear+=dt*spd*0.34;
      let step=120, off=-(bgState.cityFar%step);
      for(let x=off-step;x<W+step;x+=step){ const i=Math.floor((bgState.cityFar+x)/step), h=100+Math.floor(rand(i+13)*120); ctx.fillStyle='rgba(255,255,255,.08)'; ctx.fillRect(x,ground-h-40, step-18, h); }
      step=90; off=-(bgState.cityNear%step);
      for(let x=off-step;x<W+step;x+=step){ const i=Math.floor((bgState.cityNear+x)/step), h=120+Math.floor(rand(i+77)*170); ctx.fillStyle='rgba(255,255,255,.16)'; ctx.fillRect(x,ground-h-18, step-16, h); }
      ctx.fillStyle='rgba(0,0,0,.5)'; ctx.fillRect(0,ground,W,H-ground);
    } else if(state.bg==='space'){
      const g=ctx.createRadialGradient(W*0.7,H*0.3,H*0.1, W*0.7,H*0.3,H*0.9); g.addColorStop(0,palette.skyA); g.addColorStop(1,palette.skyB); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
      bgState.starsA+=dt*spd*0.08; bgState.starsB+=dt*spd*0.18;
      let step=28, off=-(bgState.starsA%step);
      ctx.fillStyle='rgba(255,255,255,.7)';
      for(let x=off-step;x<W+step;x+=step) for(let y=6;y<H;y+=26){ const i=Math.floor((bgState.starsA+x)/step)+Math.floor(y/26)*131; const r=rand(i+5); if(r>0.82){ const s=(r-0.82)*2.8; ctx.globalAlpha=0.5+rand(i+77)*0.5; ctx.fillRect(x,y,s,s);} }
      ctx.globalAlpha = 1;
      step=60; off=-(bgState.starsB%step);
      for(let x=off-step;x<W+step;x+=step) for(let y=12;y<H;y+=36){ const i=Math.floor((bgState.starsB+x)/step)+Math.floor(y/36)*97; const r=rand(i+31); if(r>0.7){ ctx.fillStyle='rgba(170,200,255,.9)'; ctx.beginPath(); ctx.arc(x,y,1.2+(r-0.7)*2.2,0,Math.PI*2); ctx.fill(); } }
      ctx.fillStyle='rgba(255,255,255,.07)'; ctx.fillRect(0,ground,W,H-ground);
    } else {
      const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,palette.skyA); g.addColorStop(1,palette.skyB); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
      bgState.jungleFar+=dt*spd*0.14; bgState.jungleNear+=dt*spd*0.32;
      let step=120, off=-(bgState.jungleFar%step);
      for(let x=off-step;x<W+step;x+=step){ const i=Math.floor((bgState.jungleFar+x)/step), h=90+Math.floor(rand(i+99)*120); ctx.fillStyle='rgba(0,0,0,.45)'; drawRoundedRect(x, ground-h-30, step-12, h+30, 10); ctx.fill(); }
      step=80; off=-(bgState.jungleNear%step);
      for(let x=off-step;x<W+step;x+=step){ const i=Math.floor((bgState.jungleNear+x)/step), h=100+Math.floor(rand(i+41)*140); ctx.fillStyle='rgba(255,255,255,.12)'; ctx.fillRect(x+20, ground-h-18, 16, h-18); ctx.beginPath(); ctx.arc(x+28, ground-h-18, 26+(rand(i+7)*8), 0, Math.PI*2); ctx.fill(); }
      ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect(0,ground,W,H-ground);
    }
  }

  // Heroes
  function drawHero(){
    const x=Math.floor(player.x), y=Math.floor(player.y), w=player.w, h=player.h;
    ctx.fillStyle='rgba(0,0,0,.25)'; ctx.beginPath(); ctx.ellipse(x + w*0.45, state.groundY + 10, Math.max(10, w*0.6), 8, 0, 0, Math.PI*2); ctx.fill();
    if(state.hero==='tech'){
      const body='#b91c1c', trim='#f59e0b', accent='#ef4444';
      if(!player.onGround){ ctx.fillStyle='rgba(255,180,60,.45)'; ctx.beginPath(); ctx.moveTo(x+w*0.3,y+h); ctx.lineTo(x+w*0.5,y+h+26); ctx.lineTo(x+w*0.7,y+h); ctx.closePath(); ctx.fill(); }
      drawRoundedRect(x,y+h*0.2,w,h*0.7,8); ctx.fillStyle=body; ctx.fill();
      drawRoundedRect(x+w*0.12,y,w*0.74,h*0.28,10); ctx.fillStyle=accent; ctx.fill();
      drawRoundedRect(x+w*0.22,y+h*0.06,w*0.54,h*0.14,6); ctx.fillStyle='#fde68a'; ctx.fill();
      drawRoundedRect(x+w*0.22,y+h*0.38,w*0.56,h*0.22,6); ctx.fillStyle=trim; ctx.fill();
    } else if(state.hero==='web'){
      const red='#b91c1c', blue='#1d4ed8';
      drawRoundedRect(x,y+h*0.18,w,h*0.72,8); ctx.fillStyle=blue; ctx.fill();
      drawRoundedRect(x+w*0.1,y,w*0.8,h*0.22,10); ctx.fillStyle=red; ctx.fill();
      ctx.fillStyle='#fefefe'; drawRoundedRect(x+w*0.2,y+h*0.06,w*0.18,h*0.08,4); ctx.fill(); drawRoundedRect(x+w*0.62,y+h*0.06,w*0.18,h*0.08,4); ctx.fill();
      if(!player.onGround){ ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.beginPath(); ctx.moveTo(x-16,y+h*0.6); ctx.lineTo(x,y+h*0.7); ctx.stroke(); }
    } else if(state.hero==='bolt'){
      const neon='#60a5fa', dark='#0b1730';
      drawRoundedRect(x,y+h*0.2,w,h*0.7,8); ctx.fillStyle=dark; ctx.fill();
      drawRoundedRect(x+3,y+4,w-6,h*0.3,8); ctx.fillStyle=neon; ctx.fill();
      if(player.dash>0){ ctx.strokeStyle='rgba(96,165,250,.6)'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(x-10,y+h*0.85); ctx.lineTo(x+w+10,y+h*0.62); ctx.stroke(); }
    } else if(state.hero==='shield'){
      const base='#1f2937', glow='#34d399';
      drawRoundedRect(x,y+h*0.2,w,h*0.7,8); ctx.fillStyle=base; ctx.fill();
      drawRoundedRect(x+6,y+6,w-12,h*0.28,8); ctx.fillStyle=glow; ctx.fill();
      if(player.shield>0){ ctx.strokeStyle='rgba(52,211,153,.5)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(x+w*0.5,y+h*0.5,Math.max(w,h)*0.65,0,Math.PI*2); ctx.stroke(); }
    } else { // mage
      const cape='#7c3aed', glow='#f59e0b';
      drawRoundedRect(x,y+h*0.18,w,h*0.72,8); ctx.fillStyle=cape; ctx.fill();
      drawRoundedRect(x+w*0.1,y,w*0.8,h*0.22,10); ctx.fillStyle=glow; ctx.fill();
    }
  }

  // Objects
  function drawObstacle(o){
    const g=ctx.createLinearGradient(o.x,o.y,o.x,o.y+o.h);
    g.addColorStop(0, palette.obsA); g.addColorStop(1, palette.obsB);
    drawRoundedRect(o.x,o.y,o.w,o.h,6); ctx.fillStyle=g; ctx.fill();
  }
  function drawOrb(o){
    o.pulse+=0.06; const rr=o.r+Math.sin(o.pulse)*2;
    const g=ctx.createRadialGradient(o.x,o.y,2,o.x,o.y,rr);
    g.addColorStop(0, palette.orb); g.addColorStop(1, '#ffffff');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(o.x,o.y,rr,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(o.x,o.y,rr+6,0,Math.PI*2); ctx.strokeStyle='rgba(255,255,255,.16)'; ctx.stroke();
  }
  function drawBullets(){
    ctx.fillStyle='#f59e0b';
    for(const b of bullets){ drawRoundedRect(b.x,b.y,b.w,b.h,4); ctx.fill(); ctx.fillStyle='rgba(255,255,255,.45)'; drawRoundedRect(b.x-6,b.y+2,6,b.h-4,3); ctx.fill(); ctx.fillStyle='#f59e0b'; }
  }
  function drawBoss(){
    if(!boss.active) return;
    const x=boss.x,y=boss.y,w=boss.w,h=boss.h;
    ctx.fillStyle='rgba(0,0,0,.6)'; drawRoundedRect(x,y,w,h,12); ctx.fill();
    ctx.fillStyle='#ef4444'; drawRoundedRect(x + w*0.28, y + h*0.22, w*0.44, h*0.16, 6); ctx.fill();
    ctx.fillStyle='rgba(255,255,255,.14)'; drawRoundedRect(x+8,y+h*0.5,w-16,h*0.42,10); ctx.fill();
  }
  function drawBossShots(){
    for(const s of bossShots){ ctx.fillStyle='#ef4444'; drawRoundedRect(s.x,s.y,s.w,s.h,3); ctx.fill(); }
    for(const c of bossCores){ ctx.fillStyle='rgba(99,102,241,.25)'; ctx.beginPath(); ctx.arc(c.x,c.y,c.r+6,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#6366f1'; ctx.beginPath(); ctx.arc(c.x,c.y,c.r,0,Math.PI*2); ctx.fill(); }
  }

  // FX
  function drawFX(dt){
    for(let i=fxBursts.length-1;i>=0;i--){
      const f=fxBursts[i]; f.t += dt;
      if(f.nova){
        const R=f.R * Math.min(1, f.t*2);
        ctx.strokeStyle='rgba(245,158,11,'+(0.6-f.t*0.6)+')'; ctx.lineWidth=4;
        ctx.beginPath(); ctx.arc(f.x,f.y,R,0,Math.PI*2); ctx.stroke();
        if(f.t>0.5) fxBursts.splice(i,1);
      } else {
        const r=f.r + f.t*140;
        ctx.strokeStyle='rgba(255,255,255,'+(0.8-f.t)+')';
        ctx.beginPath(); ctx.arc(f.x,f.y,r,0,Math.PI*2); ctx.stroke();
        if(f.t>0.6) fxBursts.splice(i,1);
      }
    }
  }

  // Spawning with fairness
  function spawnObstacleFair(spd){
    const ground = state.groundY;
    const type = Math.random()<0.55 ? 'box' : 'tall';
    const hMax = Math.min(160, player.h*2.2); // keep jumpable
    const h = type==='box' ? 40 + Math.random()*48 : 70 + Math.random()*(hMax-70);
    const w = type==='box' ? 44 + Math.random()*42 : 30 + Math.random()*40;

    // Fair spacing: ensure at least reactTime seconds ahead (in pixels)
    const { reactTime } = difficultyFromGrade(state.grade);
    const minGapPx = Math.max(260, spd * reactTime);
    let x = canvas.width + 20;

    // If last obstacle exists, push new one further
    if (obstacles.length) {
      const last = obstacles[obstacles.length-1];
      x = Math.max(x, last.x + last.w + minGapPx);
    }

    // Also ensure safe distance from player right now
    const heroRight = player.x + player.w;
    x = Math.max(x, heroRight + minGapPx + 80);

    obstacles.push({ x, y: ground - h, w, h, type });
  }

  function spawnOrbFair(spd){
    const ground=state.groundY;
    const y= ground - (80 + Math.random()*150);
    const x= canvas.width + 20 + Math.random()*120;
    orbs.push({ x, y, r:10, pulse:0 });
  }

  // Boss
  function spawnBoss(){
    const { bossHP } = difficultyFromGrade(state.grade);
    boss.active=true; boss.hp=bossHP; boss.maxHp=bossHP;
    boss.x=canvas.width - 180; boss.y=state.groundY - boss.h - 60; boss.t=0; boss.fireTimer=0.7; boss.coreTimer=1.3;
    bossShots.length=0; bossCores.length=0; bossBar.style.display='block'; SFX.boss();
  }
  function endBoss(defeated){
    boss.active=false; bossBar.style.display='none'; bossShots.length=0; bossCores.length=0;
    if(defeated){ state.score += 60; state.energy = clamp(state.energy+3,0,state.maxEnergy); SFX.win(); }
    state.nextBossAt += 320;
  }
  function damageBoss(n=1){ boss.hp = Math.max(0, boss.hp - n); if(boss.hp<=0) endBoss(true); }

  // Inputs with buffer
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.code]=true;
    if(['Space','ArrowUp','KeyW'].includes(e.code)){ e.preventDefault(); bufferJump(); }
    else if(['KeyF','ControlRight','ShiftRight'].includes(e.code)){ e.preventDefault(); usePower(); }
    else if(['KeyP','Escape'].includes(e.code)){ e.preventDefault(); togglePause(); }
  }, { passive:false });
  window.addEventListener('keyup', e => { keys[e.code]=false; });

  function bindTap(el, down, up){
    let pressed=false;
    el.addEventListener('touchstart', e=>{ e.preventDefault(); SFX.ensure(); pressed=true; down(); }, { passive:false });
    el.addEventListener('touchend', e=>{ pressed=false; up && up(); });
    el.addEventListener('click', e=>{ e.preventDefault(); SFX.ensure(); down(); up && up(); });
  }
  bindTap(jumpBtn, ()=>bufferJump());
  bindTap(powerBtn, ()=>usePower());
  bindTap(pauseBtn, ()=>togglePause());

  function bufferJump(){ jumpBuffer = BUFFER_MAX; }

  // Actions
  function tryJumpImmediate(){
    // Use buffer + coyote for reliability
    if (player.onGround || coyote > 0) {
      player.vy = -Math.max(720, canvas.height*0.90);
      player.onGround = false; player.doubleJump = false; jumpBuffer = 0; coyote = 0;
      SFX.jump();
      return true;
    } else if (state.hero==='web' && !player.doubleJump) {
      // Double jump for Web Racer
      player.vy = -Math.max(680, canvas.height*0.85);
      player.doubleJump = true; jumpBuffer = 0;
      SFX.jump();
      return true;
    }
    return false;
  }

  function usePower(){
    if(!state.running || state.paused) return;
    const can=n=>state.energy >= n, spend=n=>state.energy = clamp(state.energy - n, 0, state.maxEnergy);
    if (player.powerCD > 0) return;

    if (state.hero==='tech') {
      if (can(1)) {
        spend(1);
        bullets.push({ x: player.x+player.w+6, y: player.y+player.h*0.45, w:18,h:6, vx:860, life:1.2 });
        player.powerCD = 0.18; SFX.shoot();
      }
    } else if (state.hero==='web') {
      player.slowTime = 0.7; player.powerCD = 1.2; SFX.pause();
    } else if (state.hero==='bolt') {
      if (can(2)) { spend(2); player.dash = 0.5; player.powerCD = 0.7; SFX.pause(); fxBursts.push({ x:player.x+player.w*0.6, y:player.y+player.h*0.6, t:0,r:10 }); }
    } else if (state.hero==='shield') {
      if (can(3) && player.shield<=0) { spend(3); player.shield = 8.0; player.powerCD = 0.4; SFX.pause(); }
    } else if (state.hero==='mage') {
      if (can(2)) {
        spend(2); player.powerCD = 0.6;
        const R = Math.max(140, canvas.height*0.22);
        fxBursts.push({ x:player.x+player.w*0.5, y:player.y+player.h*0.5, t:0, r:12, nova:true, R });
        // Destroy nearby obstacles
        for (let i=obstacles.length-1;i>=0;i--){
          const o=obstacles[i], cx=player.x+player.w*0.5, cy=player.y+player.h*0.5;
          const dx=(o.x+o.w*0.5)-cx, dy=(o.y+o.h*0.5)-cy;
          if (dx*dx+dy*dy <= R*R) { obstacles.splice(i,1); state.score += 8; }
        }
        // Damage boss if close
        if (boss.active) {
          const cx=player.x+player.w*0.5, cy=player.y+player.h*0.5, bx=boss.x+boss.w*0.5, by=boss.y+boss.h*0.5;
          const dx=bx-cx, dy=by-cy; if(dx*dx+dy*dy <= (R + Math.max(boss.w,boss.h))**2) damageBoss(2);
        }
        SFX.shoot();
      }
    }
  }

  function togglePause(){ if(!state.running) return; state.paused = !state.paused; SFX.pause(); }

  // Reset/Start/GameOver
  function resetGame(full=false){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    player.w = Math.max(38, Math.round(canvas.height * 0.11 * 0.7));
    player.h = Math.max(54, Math.round(canvas.height * 0.11));
    player.x = Math.round(canvas.width * 0.12);
    player.y = state.groundY - player.h; player.vx=0; player.vy=0;
    player.onGround = true; player.doubleJump = false; player.powerCD=0; player.slowTime=0; player.dash=0; player.shield=0;

    bullets.length=0; obstacles.length=0; orbs.length=0; bossShots.length=0; bossCores.length=0; fxBursts.length=0;
    obstacleTimer=0; orbTimer=0; timeSinceStart=0; coyote=0; jumpBuffer=0;

    state.score=0; state.lives=state.maxLives; state.energy=2; // start with a little energy to try powers
    state.invTime=0; state.timeScale=1; boss.active=false; boss.hp=0; boss.maxHp=0; boss.t=0; boss.fireTimer=0; boss.coreTimer=0;
    state.nextBossAt = 260; bossBar.style.display='none';
  }

  function startGame(){
    state.grade = parseInt(gradeSel.value,10);
    state.hero = heroSel.value;
    state.bg = bgSel.value;
    state.perf = perfSel.value;
    palette = themes[themeSel.value] || themes.rainbow;

    gradeHUD.textContent = String(state.grade);
    menuOverlay.style.display='none'; gameOverOverlay.style.display='none';
    state.running=true; state.paused=false;
    SFX.ensure();
    resetGame(true);
  }

  function gameOver(){
    state.running=false; state.paused=false;
    finalScoreEl.textContent = String(Math.floor(state.score));
    state.best = Math.max(state.best, Math.floor(state.score));
    localStorage.setItem('heroDashBestColor', String(state.best));
    bestScoreEl.textContent = String(state.best);
    gameOverOverlay.style.display='grid';
    SFX.hit();
  }

  startBtn.addEventListener('click', ()=>{ SFX.ensure(); startGame(); });
  retryBtn.addEventListener('click', ()=>{ gameOverOverlay.style.display='none'; startGame(); });
  menuBtn.addEventListener('click', ()=>{ gameOverOverlay.style.display='none'; menuOverlay.style.display='grid'; state.running=false; });

  // Update and Render
  function update(dt){
    const { speedMul, obstacleEvery, orbEvery } = difficultyFromGrade(state.grade);
    const spd = state.baseSpeed * speedMul;

    // timers
    timeSinceStart += dt;
    if (player.slowTime>0){ player.slowTime-=dt; state.timeScale=0.6; } else state.timeScale=1;
    if (player.dash>0) player.dash-=dt;
    if (player.shield>0) player.shield-=dt;
    if (player.powerCD>0) player.powerCD-=dt;
    if (jumpBuffer>0) jumpBuffer -= dt;
    bgState.t += dt;

    // physics
    player.vy += state.gravity * dt;
    player.y += player.vy * dt;
    if (player.y + player.h >= state.groundY) { 
      if (!player.onGround) { // landed
        player.onGround = true; coyote = COYOTE_MAX;
      } else {
        player.onGround = true;
      }
      player.y = state.groundY - player.h; player.vy = 0;
    } else {
      if (player.onGround) coyote = COYOTE_MAX;
      else coyote = Math.max(0, coyote - dt);
      player.onGround = false;
    }

    // Consume buffered jump when possible
    if (jumpBuffer > 0) {
      if (tryJumpImmediate()) jumpBuffer = 0;
    }

    // spawn
    if (!boss.active) {
      obstacleTimer += dt;
      // Fair spawn delay: no obstacles in the first SAFE_START seconds
      if (timeSinceStart > SAFE_START && obstacleTimer >= obstacleEvery) {
        obstacleTimer = 0;
        spawnObstacleFair(spd);
      }
    }
    orbTimer += dt;
    if (orbTimer >= orbEvery*0.9) { orbTimer = 0; spawnOrbFair(spd); }

    // move world
    const scroll = spd * dt;

    // obstacles
    const hb = heroHitbox();
    for (let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i]; o.x -= scroll;

      // dash destroys
      if (player.dash>0 && rectsOverlap(hb, o)) { obstacles.splice(i,1); state.score += 8; continue; }

      // collision
      if (rectsOverlap(hb, o)) {
        if (state.invTime<=0) {
          if (player.shield>0) { player.shield=0; state.invTime=0.6; SFX.hit(); }
          else { state.lives -= 1; state.invTime = 1.0; player.vy = -460; SFX.hit(); if (state.lives <= 0) return gameOver(); }
        }
      }
      if (o.x + o.w < -40) obstacles.splice(i,1);
    }

    // orbs
    for (let i=orbs.length-1;i>=0;i--){
      const o=orbs[i]; o.x -= scroll;
      if (circleRectOverlap(o.x,o.y,o.r+2, hb.x,hb.y,hb.w,hb.h)) {
        state.score += 5; state.energy = clamp(state.energy + 1, 0, state.maxEnergy); orbs.splice(i,1); SFX.orb();
      } else if (o.x < -20) orbs.splice(i,1);
    }

    // bullets
    for (let i=bullets.length-1;i>=0;i--){
      const b=bullets[i]; b.x += b.vx*dt; b.life -= dt; let hit=false;
      for (let j=obstacles.length-1;j>=0;j--){ const o=obstacles[j];
        if (rectsOverlap({x:b.x,y:b.y,w:b.w,h:b.h}, o)) { obstacles.splice(j,1); state.score += 8; hit=true; break; } }
      if (!hit && boss.active && rectsOverlap({x:b.x,y:b.y,w:b.w,h:b.h}, {x:boss.x,y:boss.y,w:boss.w,h:boss.h})) { damageBoss(1); hit=true; }
      if (hit || b.life<=0 || b.x > canvas.width + 60) bullets.splice(i,1);
    }

    // boss
    if (!boss.active && state.score >= state.nextBossAt) spawnBoss();
    if (boss.active) {
      boss.t += dt; boss.y += Math.sin(boss.t*1.8)*20*dt;
      // projectiles (telegraphed slower for fairness)
      boss.fireTimer -= dt;
      if (boss.fireTimer <= 0) {
        boss.fireTimer = 1.0 - Math.min(0.45, state.grade*0.05);
        bossShots.push({ x: boss.x, y: boss.y + boss.h*(0.3+Math.random()*0.5), w:18,h:6, vx: - (140 + Math.random()*120) });
      }
      // weak cores to collect for damage
      boss.coreTimer -= dt;
      if (boss.coreTimer <= 0) { boss.coreTimer = 1.9; bossCores.push({ x: boss.x-20, y: boss.y + 20 + Math.random()*(boss.h-40), r:12, vx:-120 }); }

      for (let i=bossShots.length-1;i>=0;i--){
        const s=bossShots[i]; s.x += s.vx * dt;
        if (rectsOverlap(hb, s)) {
          if (player.dash>0) { bossShots.splice(i,1); continue; }
          if (player.shield>0) { player.shield=0; bossShots.splice(i,1); state.invTime=0.5; SFX.hit(); continue; }
          if (state.invTime<=0) { state.lives -= 1; state.invTime=1.0; bossShots.splice(i,1); SFX.hit(); if (state.lives<=0) return gameOver(); }
          else bossShots.splice(i,1);
        } else if (s.x < -40) bossShots.splice(i,1);
      }
      for (let i=bossCores.length-1;i>=0;i--){
        const c=bossCores[i]; c.x += c.vx * dt;
        if (circleRectOverlap(c.x,c.y,c.r+2, hb.x,hb.y,hb.w,hb.h)) { damageBoss(1); bossCores.splice(i,1); state.score += 6; SFX.orb(); }
        else if (c.x < -30) bossCores.splice(i,1);
      }
      if (rectsOverlap(hb, {x:boss.x,y:boss.y,w:boss.w,h:boss.h})) {
        if (player.dash>0) damageBoss(1);
        else if (player.shield>0) { player.shield=0; state.invTime=0.6; SFX.hit(); }
        else if (state.invTime<=0) { state.lives -= 1; state.invTime=1.0; player.vy=-420; SFX.hit(); if (state.lives<=0) return gameOver(); }
      }
      bossFill.style.width = ((boss.hp/boss.maxHp)*100)+'%';
      if (boss.hp>0 && state.score > state.nextBossAt + 500) endBoss(false);
    }

    if (state.invTime>0) state.invTime-=dt;

    // score and HUD
    state.score += 12 * dt * speedMul;
    scoreHUD.textContent = String(Math.floor(state.score));
    lifeFill.style.width = `${Math.max(0, (state.lives/state.maxLives)*100)}%`;
    energyFill.style.width = `${Math.max(0, (state.energy/state.maxEnergy)*100)}%`;

    // power button cooldown ring
    const cd = clamp(player.powerCD / 1.2, 0, 1); // normalized
    powerCDMask.style.setProperty('--cool', (cd*100)+'%');
  }

  function render(dt){
    const { speedMul } = difficultyFromGrade(state.grade);
    const spd = state.baseSpeed * speedMul;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground(dt, spd);

    // track lines
    if (perfDetail() >= 1) {
      const W=canvas.width, g=state.groundY;
      ctx.strokeStyle='rgba(255,255,255,.08)'; ctx.lineWidth=2; ctx.beginPath();
      for (let x=0;x<W;x+=28){ ctx.moveTo(x, g+8); ctx.lineTo(x+14, g+8); }
      ctx.stroke();
    }

    for (const o of orbs) drawOrb(o);
    for (const o of obstacles) drawObstacle(o);
    drawBoss(); drawBossShots(); drawBullets(); drawFX(dt);

    // blink when invincible
    if (state.invTime>0) {
      const blink = (Math.floor(bgState.t*20)%2===0);
      if (!blink) drawHero();
    } else drawHero();

    if (state.paused) {
      ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#eaf1ff'; ctx.font='bold 26px system-ui, sans-serif'; ctx.textAlign='center';
      ctx.fillText('Paused', canvas.width/2, canvas.height/2);
      ctx.textAlign='left';
    }
  }

  function loop(ts){
    if (!tPrev) tPrev = ts;
    let dt = (ts - tPrev) / 1000; tPrev = ts; dt = Math.min(dt, 0.05);
    if (state.running && !state.paused) update(dt * state.timeScale);
    render(dt * state.timeScale);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Init HUD
  scoreHUD.textContent = '0'; gradeHUD.textContent='3'; lifeFill.style.width='100%'; energyFill.style.width='0%';

})();
</script>
</body>
</html>